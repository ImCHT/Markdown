# 数据结构和算法

![](http://ww1.sinaimg.cn/mw690/005DF9Qily1g2dhs7u636j30do0d1dh3.jpg)

## 一、左神视频

### 1. 二叉树打印

+ 按层遍历并能记住层数：宽度优先搜索BFS

+ 二叉树的序列化和反序列化：二叉树与字符串相互转换。
  1. 先序中序和后续遍历的方式：普通节点值后面加上"!"，空节点用"#"表示并也在后面加上"!"
  2. 层序遍历的方式：普通节点值后面加上"!"，空节点用"#"表示并也在后面加上"!"

### 2. 排序

**冒泡排序**

+ 时间复杂度O(N2)
+ 空间复杂度O(1)
+ 稳定

**选择排序**

+ 时间复杂度O(N2)
+ 空间复杂度O(1)
+ 不稳定。2221,1与最前面的2交换，破坏了稳定性。

**插入排序**

+ 时间复杂度O(N2)
+ 空间复杂度O(1)
+ 稳定

**归并排序**

+ 时间复杂度O(NlogN)
+ 空间复杂度O(N)
+ 稳定。5115，步长为2时，5会和第二个1交换。

**快速排序**

+ 时间复杂度O(NlogN)
+ 空间复杂度O(logN~O(N)
+ 不稳定。43335，选中间的数作为基准，其他2个3要么都在中间3的左边，要么都在右边。

**堆排序**

+ 时间复杂度O(NlogN)
+ 空间复杂度O(1)
+ 不稳定。222，建立大根堆之后，2放到最后的位置，破坏了稳定性。

**希尔排序**

+ 时间复杂度O(NlogN)
+ 空间复杂度O(1)
+ 不稳定

**计数排序（基于桶排序）**

+ 时间复杂度O(N)
+ 空间复杂度O(M)，取决于痛的数量，即数值范围
+ 年龄、升高。数值在一定范围之内。
+ 稳定

**基数排序（基于桶排序）**

+ 时间复杂度O(N)
+ 空间复杂度O(M)，取决于痛的数量，即数的位数。
+ 稳定

**补充说明一**

排序算法无绝对优劣。

**补充说明二**

快速排序在最好情况下，它的渐进复杂度和堆排序及归并排序相同，只不过常量系数较小。

**补充说明三**

1. 工程上的排序是综合排序
2. 数组较小时，插入排序
3. 数组较大时，快速排序或者其他O(NlogN)的排序

## 二、剑指offer

1. 数组中重复的数字

   在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的，也不知道每个数字重复几次。请找出数组中任意一个重复的数字。

   ```html
   Input:
   {2, 3, 1, 0, 2, 5}
   
   Output:
   2
   ```

   + 扫描+哈希：时间复杂度O(n)，空间复杂度O(n)
   + 排序+扫描：时间复杂度O(nlogn)，空间复杂度O(1)
   + 对于这种数组元素在 [0, n-1] 范围内的问题，可以将值为 i 的元素调整到第 i 个位置上进行求解。时间复杂度O(n)空间复杂度O(1)。

2. 二维数组中的查找

   给定一个二维数组，其每一行从左到右递增排序，从上到下也是递增排序。给定一个数，判断这个数是否在该二维数组中。

   ```html
   Consider the following matrix:
   [
     [1,   4,  7, 11, 15],
     [2,   5,  8, 12, 19],
     [3,   6,  9, 16, 22],
     [10, 13, 14, 17, 24],
     [18, 21, 23, 26, 30]
   ]
   
   Given target = 5, return true.
   Given target = 20, return false.
   ```

+ 该二维数组中的一个数，它左边的数都比它小，下边的数都比它大。因此，从右上角开始查找，就可以根据 target 和当前元素的大小关系来缩小查找区间，当前元素的查找区间为左下角的所有元素。时间复杂度O(N+M)，空间复杂度O(1)

3. 替换空格

   将一个字符串中的空格替换成 "%20"。

   ```text
   Input:
   "A B"
   
   Output:
   "A%20B"
   ```

+ 先扫描字符串，得知空格个数，算出新字符串的长度。然后双指针从后往前遍历，一个指向原来字符串末尾，一个指向新字符串末尾，原来字符串不为空格直接复制，为空格逆序插入"%20"。新旧字符串可以为同一个。时间复杂度O(n)，空间复杂度O(n)。

4. 从尾到头打印链表

   从尾到头反过来打印出每个结点的值。

   + 用递归
   + 使用栈
   + 正向遍历链表，将值存入数组，反向遍历数组输出
   + **利用链表的头插法为逆序的特点，用头插法构建逆序链表。然后遍历逆序链表。可以在原来的链表上构建，也可以构建新链表。（之后可以写一下）**

5. **重建二叉树**（没写）

   根据二叉树的前序遍历和中序遍历的结果，重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

   ```html
   preorder = [3,9,20,15,7]
   inorder =  [9,3,15,20,7]
   ```

+ 前序遍历的第一个值为根节点的值，使用这个值将中序遍历结果分成两部分，左部分为树的左子树中序遍历结果，右部分为树的右子树中序遍历的结果。

6. 二叉树的下一个结点

   给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。

   + 如果一个节点的右子树不为空，那么该节点的下一个节点是右子树的最左节点；

     ![](http://ww1.sinaimg.cn/mw690/005DF9Qily1g2dixwd1lpg309k08i0sr.gif)

   + 否则，向上找第一个左链接指向的树包含该节点的祖先节点。

     ![](http://ww1.sinaimg.cn/large/005DF9Qily1g2diynx97lg309k08i0ss.gif)

7. 用两个栈实现队列

   用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。

   + 插入数据时，放入栈1。取数据时，若栈2为空，则将栈1的数据全都弹出到栈2，然后从栈2中取数据；若栈2不为空，直接取栈2的数据。

8. 斐波那契数列

   求斐波那契数列的第 n 项，n <= 39。

   ![](http://ww1.sinaimg.cn/mw690/005DF9Qily1g2dj5nftntj30d803i0so.jpg)

+ 用普通递归
+ 用动态规划减少运算量

9. **矩形覆盖**

   我们可以用 21 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 21 的小矩形无重叠地覆盖一个 2*n 的大矩形，总共有多少种方法？

   + 递归，与之前有关

   + 动态规划

10. 跳台阶

   一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。

   + 动态规划
   + 递归

11. 变态跳台阶

    一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级... 它也可以跳上 n 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。

    + f(n) = f(n-1) + f(n-2) + ... + f(0)

12. 旋转数组的最小数字

    把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。

    解法：

    例如数组 {3, 4, 5, 1, 2} 为 {1, 2, 3, 4, 5} 的一个旋转，该数组的最小值为 1。

    在一个有序数组中查找一个元素可以用二分查找，二分查找也称为折半查找，每次都能将查找区间减半，这种折半特性的算法时间复杂度都为 O(logN)。

    1. 本题可以修改二分查找算法进行求解：

    - 当 nums[m] <= nums[h] 的情况下，说明解在 [l, m] 之间，此时令 h = m；
    - 否则解在 [m + 1, h] 之间，令 l = m + 1。

    2. 如果数组元素允许重复的话，那么就会出现一个特殊的情况：nums[l] == nums[m] == nums[h]，那么此时无法确定解在哪个区间，**需要切换到顺序查找**。例如对于数组 {1,1,1,0,1}，l、m 和 h 指向的数都为 1，此时无法知道最小数字 0 在哪个区间。

13. **矩阵中的路径**

    请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。

    + 深度优先搜索，回溯法

14. **机器人的运动范围**

    地上有一个 m 行和 n 列的方格。一个机器人从坐标 (0, 0) 的格子开始移动，每一次只能向左右上下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于 k 的格子。

    例如，当 k 为 18 时，机器人能够进入方格 (35,37)，因为 3+5+3+7=18。但是，它不能进入方格 (35,38)，因为 3+5+3+8=19。请问该机器人能够达到多少个格子？

    + 深度优先搜索

15. **剪绳子**

    把一根绳子剪成多段，并且使得每段的长度乘积最大。

    ```html
    n = 2
    return 1 (2 = 1 + 1)
    
    n = 10
    return 36 (10 = 3 + 3 + 4)
    ```

+ 贪心

  尽可能多剪长度为 3 的绳子，并且不允许有长度为 1 的绳子出现。如果出现了，就从已经切好长度为 3 的绳子中拿出一段与长度为 1 的绳子重新组合，把它们切成两段长度为 2 的绳子。

  证明：当 n >= 5 时，3(n - 3) - n = 2n - 9 > 0，且 2(n - 2) - n = n - 4 > 0。因此在 n >= 5 的情况下，将绳子剪成一段为 2 或者 3，得到的乘积会更大。又因为 3(n - 3) - 2(n - 2) = n - 5 >= 0，所以剪成一段长度为 3 比长度为 2 得到的乘积更大。

+ 动态规划

16. 二进制中 1 的个数

    输入一个整数，输出该数二进制表示中 1 的个数。

    + n&(n-1)
      该位运算去除 n 的位级表示中最低的那一位。时间复杂度为O(M)，M为二进制中1的个数
    + Integer.bitCount()

17. 数值的整数次方

    题目描述：

    给定一个 double 类型的浮点数 base 和 int 类型的整数 exponent，求 base 的 exponent 次方。

    解题思路：

    下面的讨论中 x 代表 base，n 代表 exponent。

    ![](http://ww1.sinaimg.cn/mw690/005DF9Qily1g2dn48vx9fj30bm02l0so.jpg)

    因为 (x*x)n/2 可以通过递归求解，并且每次递归 n 都减小一半，因此整个算法的时间复杂度为 O(logN)。

18. 打印从 1 到最大的 n 位数

    题目描述：
    输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数即 999。

    解题思路：

    + 由于 n 可能会非常大，因此不能直接用 int 表示数字，而是用 char 数组进行存储。

      深度优先遍历，回溯法。

19. 在 O(1) 时间内删除链表节点

    解题思路：

    + 如果链表只有一个节点，那么直接返回null
    + 如果该节点不是尾节点，那么可以直接将下一个节点的值赋给该节点，然后令该节点指向下下个节点，时间复杂度为 O(1)。
    + 否则，就需要先遍历链表，找到节点的前一个节点，然后让前一个节点指向 null，时间复杂度为 O(N)。

20. 删除链表中重复的结点

    题目描述：

    ![](http://ww1.sinaimg.cn/mw690/005DF9Qily1g2dnigekjaj30i805q0sq.jpg)

    解题思路：

    + 从头节点开始遍历链表，判断下个节点和下下个节点一不一样。一样的话进入循环删除节点，出循环之前把下一节点给删了

21. - [ ] **正则表达式匹配**

    题目描述：
    请实现一个函数用来匹配包括 '.' 和 '*' 的正则表达式。模式中的字符 '.' 表示任意一个字符，而 '*' 表示它前面的字符可以出现任意次（包含 0 次）。

    在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串 "aaa" 与模式 "a.a" 和 "ab*ac*a" 匹配，但是与 "aa.a" 和 "ab*a" 均不匹配。
    
22. 表示数值的字符串

    题目描述：

    ```
    true
    "+100"
    "5e2"
    "-123"
    "3.1416"
    "-1E-16"
    false
    "12e"
    "1a3.14"
    "1.2.3"
    "+-5"
    "12e+4.3"
    ```

    思路：

    使用正则表达式进行匹配。

    ```html
    []  ： 字符集合
    ()  ： 分组
    ?   ： 重复 0 ~ 1
    +   ： 重复 1 ~ n
    *   ： 重复 0 ~ n
    .   ： 任意字符
    \\. ： 转义后的 .
    \\d ： 数字
    ```

    ```java
    public boolean isNumeric(char[] str) {
        if (str == null || str.length == 0)
            return false;
        return new String(str).matches("[+-]?\\d*(\\.\\d+)?([eE][+-]?\\d+)?");
    }
    ```

23. 调整数组顺序使奇数位于偶数前面

    题目描述：

    需要保证奇数和奇数，偶数和偶数之间的相对位置不变。

    解题思路：

    + 如果不需要相对位置不变的话，可以用快排的切分函数，前后双指针，交换
    + 遍历数组，统计奇数数量，然后复制原来的数组，遍历数组，将数字复制到原数组合适位置

24. 链表中倒数第 K 个结点

    解题思路：

    + 双指针，一个指针先移动k步，然后两个指针一起以1的步长移动，直到前面指针到达null，后一个指针指向的结点就是倒数第K个节点

25. 链表中环的入口结点

    题目描述：
    一个链表中包含环，请找出该链表的环的入口结点。要求不能使用额外的空间。

    解题思路：

    + 先用快慢指针，一个走一步，一个走两步，它们相遇的位置肯定在环内。然后一个不懂，一个走，相遇时，可以统计出环的大小。然后从头开始，一个指针先走环的大小的步数，两个指针相遇的时候就是环的入口节点。
    + 遍历链表，将节点存入List，之后遍历时扫描List看有没有重复节点，第一个重复节点就是环的入口节点。

26. 反转链表

    解题思路：

    + 递归
    + 三个指针
    + 头插法

27. 合并两个排序的链表

    解题思路：

    + 创建个新链表，进行比较复制
    + 头插法

28. - [ ] 二叉树的镜像

    + 交换左右节点，递归

29. - [ ] 栈的压入，弹出序列

    解题思路：

    + 是不减序列。用两个变量，一个存已经出来的最大值，一个存次大值。如果新的弹出值比最大值小，那它一定要刚好在次大值之前。
    + 用一个栈来模拟。遍历压入序列，同时扫描弹出序列，如果栈顶不是所要的值，压入栈，否则弹出。遍历完毕，如果栈为空，则匹配。

30. 之字形打印二叉树

    + 按层序遍历的方法，分层加入数据。布尔值判断方向

31. - [ ] 二叉搜索树与双向链表转换

    解题思路：

    ```java
    private TreeNode pre = null;
    private TreeNode head = null;
    
    public TreeNode Convert(TreeNode root) {
        inOrder(root);
        return head;
    }
    
    private void inOrder(TreeNode node) {
        if (node == null)
            return;
        inOrder(node.left);
        node.left = pre;
        if (pre != null)
            pre.right = node;
        pre = node;
        if (head == null)
            head = node;
        inOrder(node.right);
    }
    ```

32. - [ ] 字符串的排列（全排列）

    题目描述：
    输入一个字符串，按字典序打印出该字符串中字符的所有排列。例如输入字符串 abc，则打印出由字符 a, b, c 所能排列出来的所有字符串 abc, acb, bac, bca, cab 和 cba。

    解题思路：

    + 回溯法。如果有相同字符时，要保证不重复。

33. 数组中出现次数超过一半的数字

    解题思路：

    + 排序+取中间。时间复杂度O(nlogn)
    + 多数投票问题，可以利用 Boyer-Moore Majority Vote Algorithm 来解决这个问题，使得时间复杂度为 O(N)。使用 cnt 来统计一个元素出现的次数，当遍历到的元素和统计元素相等时，令 cnt++，否则令 cnt--。记住让cnt为1的字符。

34. 数据流中的中位数

    + 左边大顶堆，右边小顶堆。右边元素都大于左半边。

35. 字符流中第一个不重复的字符

    + 用一个队列+字符数组。插入字符串时，如果此字符有重复，则出列。
    
36. 连续子数组的最大和

    + 遍历数组
    
37. 1~n整数中1出现的次数

    解题思路：

    + 一个个统计1出现的次数
    + 找规律

38. 数字序列中某一位的数字

    解题思路：

    + 枚举
    + 找规律，跳过一些数字。递归

39. 把数组排成最小的数

    + 全排列找出最小的数，比较
    + 根据两个数字组成最小数的规则。组合所有的数。

40. 把数字翻译成字符串

    解题思路：

    + 动态规划

41. 礼物的最大价值

    解题思路：

    + 回溯法

42. 最长不含重复字符串的子字符串

    + 动态规划
