## [Java虚拟机](https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA) 

### 1. 运行时数据区域

程序计数器，虚拟机栈，本地方法栈，堆，方法区（直接内存）。

**程序计数器**

记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。

**Java 虚拟机栈**

每个 Java 方法在执行的同时会创建一个栈帧用于**存储局部变量表、操作数栈、常量池引用**等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。

可以通过 **-Xss** 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小：

```java
java -Xss512M HackTheJavaCopy to clipboardErrorCopied
```

该区域可能抛出以下异常：

- 当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；
- 栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。

**本地方法栈**

本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。

本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。

**堆**

所有对象都在这里分配内存，是垃圾收集的主要区域（"GC 堆"）。

现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。可以将堆分成两块：

- 新生代（Young Generation）
- 老年代（Old Generation）

堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。

可以通过 **-Xms 和 -Xmx** 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。

```java
java -Xms1M -Xmx2M HackTheJava
```

**方法区**

用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。

对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。

HotSpot 虚拟机把它当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。

**运行时常量池**

运行时常量池是方法区的一部分。

Class 文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域。

除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。

**直接内存**

在 JDK 1.4 中新引入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在堆内存和堆外内存来回拷贝数据。

### [2. 垃圾收集](https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA?id=%e4%ba%8c%e3%80%81%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86)

垃圾收集主要是针对堆和方法区进行。程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收。

[判断一个对象是否可被回收](https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA?id=%e5%88%a4%e6%96%ad%e4%b8%80%e4%b8%aa%e5%af%b9%e8%b1%a1%e6%98%af%e5%90%a6%e5%8f%af%e8%a2%ab%e5%9b%9e%e6%94%b6)

1. 引用计数算法

2. 可达性分析算法

   Java 虚拟机使用该算法来判断对象是否可被回收，GC Roots 一般包含以下内容：

   - 虚拟机栈中局部变量表中引用的对象
   - 本地方法栈中 JNI 中引用的对象
   - 方法区中类静态属性引用的对象
   - 方法区中的常量引用的对象

3. 方法区的回收

   主要是对常量池的回收和对类的卸载。

   类的卸载条件很多，需要满足以下三个条件，并且满足了条件也不一定会被卸载：

   - 该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。
   - 加载该类的 ClassLoader 已经被回收。
   - 该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。

4. finalize()

   类似 C++ 的析构函数，用于关闭外部资源。但是 try-finally 等方式可以做得更好，并且该方法运行代价很高，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。

   当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会再调用该方法。

[引用类型](https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA?id=%e5%bc%95%e7%94%a8%e7%b1%bb%e5%9e%8b)

1. 强引用
2. 软引用
3. 弱引用
4. 虚引用

[垃圾收集算法](https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA?id=%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86%e7%ae%97%e6%b3%95)

1. 标记清除
2. 标记整理
3. 复制
4. 分代收集

[垃圾收集器](https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA?id=%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86%e5%99%a8)

1. Serial收集器

2. SerialOld收集器

3. ParNew收集器

4. ParallelOld收集器

5. ParallelScavenge收集器

   新生代，可控的吞吐量。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。

6. CMS收集器

   CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。低停顿时间。

   停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。

   分为以下四个流程：

   - 初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。
   - 并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。
   - 重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。
   - 并发清除：不需要停顿。

   在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。

   具有以下缺点：

   - 吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。
   - 无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。
   - 标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。

7. [G1 收集器](https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA?id=_7-g1-%e6%94%b6%e9%9b%86%e5%99%a8)

   G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。

   堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。

### [3. 内存分配与回收策略](https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA?id=%e4%b8%89%e3%80%81%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e4%b8%8e%e5%9b%9e%e6%94%b6%e7%ad%96%e7%95%a5)

[Minor GC 和 Full GC](https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA?id=minor-gc-%e5%92%8c-full-gc)

- Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。
- Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。

[内存分配策略](https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA?id=%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e7%ad%96%e7%95%a5)

1. 对象优先在 Eden 分配
2. 大对象直接进入老年代
3. 长期存活的对象进入老年代
4. 动态对象年龄判定
5. 空间分配担保

[Full GC 的触发条件](https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA?id=full-gc-%e7%9a%84%e8%a7%a6%e5%8f%91%e6%9d%a1%e4%bb%b6)

1. 调用 System.gc()
2. 老年代空间不足
3. 空间分配担保失败
4. JDK 1.7 及以前的永久代空间不足
5. Concurrent Mode Failure

### [4. 类加载机制](https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA?id=%e5%9b%9b%e3%80%81%e7%b1%bb%e5%8a%a0%e8%bd%bd%e6%9c%ba%e5%88%b6)

类是在运行期间第一次使用时动态加载的，而不是一次性加载所有类。因为如果一次性加载，那么会占用很多的内存。

包括以下 7 个阶段：

- **加载（Loading）**
- **验证（Verification）**
- **准备（Preparation）**
- **解析（Resolution）**
- **初始化（Initialization）**
- 使用（Using）
- 卸载（Unloading）

**类加载过程**

包含了加载、验证、准备、解析和初始化这 5 个阶段。

**类初始化时机**

1. 主动引用

2. 被动引用

   以上 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括：

   - 通过子类引用父类的静态字段，不会导致父类初始化。
   - 通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。
   - 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。

**类与类加载器**

两个类相等，需要类本身相等，并且使用同一个类加载器进行加载。这是因为每一个类加载器都拥有一个独立的类名称空间。

这里的相等，包括类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果为 true，也包括使用 instanceof 关键字做对象所属关系判定结果为 true。

**类加载器分类**

从 Java 虚拟机的角度来讲，只存在以下两种不同的类加载器：

- 启动类加载器（Bootstrap ClassLoader），使用 C++ 实现，是虚拟机自身的一部分；
- 所有其它类的加载器，使用 Java 实现，独立于虚拟机，继承自抽象类 java.lang.ClassLoader。

从 Java 开发人员的角度看，类加载器可以划分得更细致一些：

- 启动类加载器（Bootstrap ClassLoader）此类加载器负责将存放在 <JRE_HOME>\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。
- 扩展类加载器（Extension ClassLoader）这个类加载器是由 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将 <JAVA_HOME>/lib/ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。
- 应用程序类加载器（Application ClassLoader）这个类加载器是由 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

**双亲委派模型**

1. 工作过程

   一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载。

2. 好处

   使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。

3. 实现

**自定义类加载器实现**

5. 说一下 jvm 的主要组成部分？及其作用？

   - 类加载器（ClassLoader）
   - 运行时数据区（Runtime Data Area）
   - 执行引擎（Execution Engine）
   - 本地库接口（Native Interface）

   组件的作用： 首先通过类加载器（ClassLoader）会把 Java 代码转换成字节码，运行时数据区（Runtime Data Area）再把字节码加载到内存中，而字节码文件只是 JVM 的一套指令集规范，并不能直接交个底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。

6. 说一下 jvm 运行时数据区？

   - 程序计数器
   - 虚拟机栈
   - 本地方法栈
   - 堆
   - 方法区

   有的区域随着虚拟机进程的启动而存在，有的区域则依赖用户进程的启动和结束而创建和销毁。

   ![](http://wx1.sinaimg.cn/large/005DF9Qily1g2gdbig5dxj30d70b2goy.jpg)

7. 说一下堆栈的区别？

   1. 栈内存存储的是局部变量而堆内存存储的是实体；

   2. 栈内存的更新速度要快于堆内存，因为局部变量的生命周期很短；

   3. 栈内存存放的变量生命周期一旦结束就会被释放，而堆内存存放的实体会被垃圾回收机制不定时的回收。

8. 说一下类加载的执行过程？

   类加载分为以下 5 个步骤：

   1. 加载：根据查找路径找到相应的 class 文件然后导入；
   2. 检查：检查加载的 class 文件的正确性；
   3. 准备：给类中的静态变量分配内存空间；
   4. 解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；
   5. 初始化：对静态变量和静态代码块执行初始化工作。

9. 说一下 jvm 有哪些垃圾回收算法？

   - 标记-清除算法
   - 标记-整理算法
   - 复制算法
   - 分代算法

10. 说一下 jvm 有哪些垃圾回收器？

    - Serial：最早的单线程串行垃圾回收器。
    - Serial Old：Serial 垃圾回收器的老年版本，同样也是单线程的，可以作为 CMS 垃圾回收器的备选预案。
    - ParNew：是 Serial 的多线程版本。
    - ParallelScavenge 和 ParNew 收集器类似是多线程的，但 ParallelScavenge 是吞吐量优先的收集器，可以牺牲等待时间换取系统的吞吐量。
    - Parallel Old 是 Parallel 老生代版本，Parallel 使用的是复制的内存回收算法，Parallel Old 使用的是标记-整理的内存回收算法。
    - CMS：一种以获得最短停顿时间为目标的收集器，非常适用 B/S 系统。
    - G1：一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项。

    ![](http://wx1.sinaimg.cn/large/005DF9Qily1g2gdk6jheaj30dw08pmxb.jpg)

11. 说一下 jvm 调优的工具？

    JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。

    - jconsole：用于对 JVM 中的内存、线程和类等进行监控；
    - jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。

12. 常用的 jvm 调优的参数都有哪些？

    - -Xms 2g：初始化堆大小为 2g；
    - -Xmx 2g：堆最大内存为 2g；
    - -XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；
    - -XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；
    - –XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；
    - -XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；
    - -XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；
    - -XX:+PrintGC：开启打印 gc 信息；
    - -XX:+PrintGCDetails：打印 gc 详细信息。