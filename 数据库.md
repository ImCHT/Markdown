## MySQL

1. 数据库的三范式

   - 第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。
   - 第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。
   - 第三范式：任何非主属性不依赖于其它非主属性。

2. 事务的ACID 

   - Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。
   - Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。
   - Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。
   - Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

3. char 和 varchar 的区别是什么？

   char(n) ：固定长度类型，比如订阅 char(10)，当你输入"abc"三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。

   chat 优点：效率高；缺点：占用空间；适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。

   varchar(n) ：可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。

   所以，从空间上考虑 varcahr 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡。

4. mysql 的内连接、左连接、右连接有什么区别？

   内连接关键字：inner join；左连接：left join；右连接：right join。

   内连接是把匹配的关联数据显示出来；左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反。

5. mysql 索引是怎么实现的？

   索引是满足某种特定查找算法的数据结构，而这些数据结构会以某种方式指向数据，从而实现高效查找数据。

   具体来说 MySQL 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 B+ 树实现的，B+ 树的搜索效率，可以到达二分法的性能，找到数据区域之后就找到了完整的数据结构了。

6. 怎么验证 mysql 的索引是否满足需求？

   使用 explain 查看 SQL 是如何执行查询语句的，从而分析你的索引是否满足需求。

   explain 语法：explain select * from table where type=1。

7. 说一下数据库的事务隔离？

   MySQL 的事务隔离是在 MySQL. ini 配置文件里添加的，在文件的最后添加：transaction-isolation = REPEATABLE-READ

   可用的配置值：READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE。

   READ-UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。

   READ-COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。

   REPEATABLE-READ：可重复读，默认级别，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读）。

   SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。

   脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。

   不可重复读 ：是指在一个事务内，多次读同一数据。

   幻读：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。

8. 索引种类

   https://www.cnblogs.com/luyucheng/p/6289714.html

- 全文索引：目前只有MyISAM支持
  
  主要用来查找文本加密中的关键字，而不是直接与索引中的值相比较。fulltext索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的where语句的参数匹配。fulltext索引配合match against操作使用，而不是一般的where语句加like。
  
     可以在CREATE TABLE ，ALTER TABLE ，CREATE INDEX 使用，不过目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引
  
     ```sql
  创建ALTER TABLE table ADD INDEX `FULLINDEX` USING FULLTEXT(`cname1`[,cname2…]);
     使用SELECT * FROM table WHERE MATCH(cname1[,cname2…]) AGAINST ('word' MODE );
     ```
  
- HASH
  
  Hash 索引仅仅能满足"=","IN"和"<=>"查询，不能使用范围查询。
  
  Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。 
  
- B+TREE
  
  BTREE索引就是一种将索引值按一定的算法，存入一个树形的数据结构中
  
- 普通索引
  
     是最基本的索引，它没有任何限制。
   
  ```sql
     CREATE INDEX index_name ON table(column(length))
  ```
  
- 唯一索引
  
     与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。
   
  ```sql
     CREATE UNIQUE INDEX indexName ON table(column(length))
  ```
  
- 主键索引
  
     是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引：
   
     ```sql
     CREATE TABLE `table` (
         `id` int(11) NOT NULL AUTO_INCREMENT ,
         `title` char(255) NOT NULL ,
      PRIMARY KEY (`id`)
     );
  ```
  
- 组合索引
  
     指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循最左前缀集合
   
     ```sql
     ALTER TABLE `table` ADD INDEX name_city_age (name,city,age); 
     ```

9. 说一下 mysql 常用的引擎？

   InnoDB 引擎：InnoDB 引擎提供了对数据库 acid 事务的支持，并且还提供了行级锁和外键的约束，它的设计的目标就是处理大数据容量的数据库系统。MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎是不支持全文搜索，同时启动也比较的慢，它是不会保存表的行数的，所以当进行 select count(*) from table 指令的时候，需要进行扫描全表。由于锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的。

   MyIASM 引擎：MySQL 的默认引擎，但不提供事务的支持，也不支持行级锁和外键。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和 InnoDB 不同的是，MyIASM 引擎是保存了表的行数，于是当进行 select count(*) from table 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。

10. 说一下 mysql 的行锁和表锁？

    MyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。

    - 表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。
    - 行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。

11. 如何做 mysql 的性能优化？

    - 为搜索字段创建索引。
    - 避免使用 select *，列出需要查询的字段。
    - 垂直分割分表。
    - 选择正确的存储引擎。

## Redis

1. redis 是什么？都有哪些使用场景？

   Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。

   Redis 使用场景：

   - 数据高并发的读写
   - 海量数据的读写
   - 对扩展性要求高的数据

2. redis 有哪些功能？

   - 数据缓存功能
   - 分布式锁的功能
   - 支持数据持久化
   - 支持事务
   - 支持消息队列

3. redis 为什么是单线程的？

   因为 cpu 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存或者网络带宽。既然单线程容易实现，而且 cpu 又不会成为瓶颈，那就顺理成章地采用单线程的方案了。

   关于 Redis 的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。

   而且单线程并不代表就慢 nginx 和 nodejs 也都是高性能单线程的代表。

4. 什么是缓存穿透？怎么解决？

   缓存穿透

   指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。

   解决方案

   + 最简单粗暴的方法如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们就把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。
   + 用布隆过滤器

5. redis 支持的数据类型有哪些？

   string、list、hash、set、zset。

6. 怎么保证缓存和数据库数据的一致性？

   - 合理设置缓存的过期时间。
   - 新增、更改、删除数据库操作时同步更新 Redis，可以使用事物机制来保证数据的一致性。

7. redis 持久化有几种方式？

   Redis 的持久化有两种方式，或者说有两种策略：

   - RDB（Redis Database）：指定的时间间隔能对你的数据进行快照存储。
   - AOF（Append Only File）：每一个收到的写命令都通过write函数追加到文件中。

8. redis 淘汰策略有哪些？

   - volatile-lru：从已设置过期时间的数据集（server. db[i]. expires）中挑选最近最少使用的数据淘汰。
   - volatile-ttl：从已设置过期时间的数据集（server. db[i]. expires）中挑选将要过期的数据淘汰。
   - volatile-random：从已设置过期时间的数据集（server. db[i]. expires）中任意选择数据淘汰。
   - allkeys-lru：从数据集（server. db[i]. dict）中挑选最近最少使用的数据淘汰。
   - allkeys-random：从数据集（server. db[i]. dict）中任意选择数据淘汰。
   - no-enviction（驱逐）：禁止驱逐数据。

9. redis 常见的性能问题有哪些？该如何解决？

   - 主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照。
   - Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内。

